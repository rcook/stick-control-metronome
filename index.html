<!DOCTYPE html>
<html>

<head>
  <title>Stick Control Metronome</title>
  <link rel="icon" href="favicon.ico" type="image/x-icon">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: Verdana, Geneva, Tahoma, sans-serif;
      margin: 0px;
      display: flex;
      height: 100vh;
      align-items: center;
      background-color: limegreen;
    }

    #container {
      width: fit-content;
      margin: 0 auto;
    }

    .dots {
      display: flex;
      height: 200px;
    }

    .dots.last {
      background-color: pink;
    }

    .dot {
      width: 125px;
      height: 125px;
      border-radius: 50%;
      border: 5px solid green;
      display: grid;
      align-items: center;
      text-align: center;
      font-size: 2em;
      margin: 20px;
      color: lime;
    }

    .current {
      background-color: lightgreen;
      color: darkgreen;
    }

    #progress-repetitions,
    #progress-bars {
      font-size: 5em;
    }

    #controls {
      display: flex;
    }

    #fields {
      display: inline;
      border: none;
    }

    #fields div {
      display: inline-block;
    }

    #fields label {
      display: block;
    }

    #fields input,
    #fields select {
      box-sizing: border-box;
      vertical-align: top;
      height: 32px;
      padding: 5px;
    }

    #buttons {
      align-content: center;
    }

    #buttons button {
      height: 32px;
    }

    .last {
      color: red;
    }

    #progress-exercise {
      font-size: 3em;
    }

    #progress-repetition,
    #progress-bar {
      font-size: 2em;
    }
  </style>
</head>

<body>
  <div id="container">
    <div id="indicators">
      <div id="progress-exercise">&ndash;&ndash;&ndash;</div>
      <div id="progress-repetition">&ndash;&ndash;&ndash;</div>
      <div id="progress-bar">&ndash;&ndash;&ndash;</div>
      <div id="dots" class="dots"></div>
    </div>
    <div id="controls">
      <div id="buttons">
        <button id="start-stop">Start</button>
      </div>
      <fieldset id="fields">
        <div>
          <input id="tempo" type="number" min="30" max="250" step="1">
          <label for="tempo">tempo</label>
        </div>
        <div>
          <input id="exercises" type="number" min="1" max="100" step="1">
          <label for="exercises">exercises</label>
        </div>
        <div>
          <input id="repetitions" type="number" min="1" max="100" step="1">
          <label for="repetitions">reps</label>
        </div>
        <div>
          <input id="bars" type="number" min="1" max="4" step="1">
          <label for="bars">bars</label>
        </div>
        <div>
          <input id="beats" type="number" min="1" max="16" step="1">
          <label for="beats">beats</label>
        </div>
        <div>
          <select id="subdivisions">
            <option value="1">&#9833;</option>
            <option value="2">&#9834;</option>
            <option value="4">&#119137;</option>
          </select>
          <label for="subdivisions">subs</label>
        </div>
        <div>
          <input id="pattern" type="text">
          <label for="pattern">pattern</label>
        </div>
        <div>
          <input id="preroll-bars" type="number" min="1" max="100" step="1">
          <label for="preroll-bars">preroll</label>
        </div>
      </fieldset>
    </div>
  </div>
</body>

<script>
  //<![CDATA[
  const HIGH = "A";
  const MEDIUM = "B";
  const LOW = "C";
  const SILENT = "D";
  const HIGH_FREQUENCY = 880;
  const MEDIUM_FREQUENCY = 440;
  const LOW_FREQUENCY = 220;
  const BEEP_DURATION = 0.1;

  const DEFAULT_TEMPO = 120;
  const DEFAULT_EXERCISES = 24;
  const DEFAULT_REPETITIONS = 20;
  const DEFAULT_BARS = 2;
  const DEFAULT_BEATS = 4;
  const DEFAULT_SUBDIVISIONS = 2;
  const DEFAULT_PREROLL_BARS = 2;

  const IDLE_HTML = "&ndash;&ndash;&ndash;";

  function makeDefaultPattern(beats, subdivisions) {
    let pattern = "";
    for (let i = 0; i < beats; ++i) {
      if (i == 0) {
        pattern += HIGH;
      } else {
        pattern += MEDIUM;
      }

      for (let j = 0; j < subdivisions - 1; ++j) {
        pattern += LOW;
      }
    }

    console.assert(pattern.length == beats * subdivisions);
    return pattern;
  }

  function parsePattern(s, beats, subdivisions) {
    const len = beats * subdivisions;
    return s.substring(0, len).padEnd(len, "D");
  }

  function formatProgress(name, value, count) {
    return `${name} ${value + 1} of ${count}`;
  }

  class Queue {
    constructor() {
      this.notes = [];
    }

    isEmpty() {
      return this.notes.length == 0;
    }

    enqueue(note) {
      this.notes.push(note);
    }

    dequeue() {
      if (this.isEmpty()) {
        return null;
      }

      return this.notes.shift();
    }

    peek() {
      if (this.isEmpty()) {
        return null;
      }
      return this.notes[0];
    }

    clear() {
      this.notes.length = 0;
    }
  }

  class Beeper {
    constructor(options) {
      this.audioCtx = options.audioCtx;
      this.tempo = options.tempo;
      this.beats = options.beats;
      this.subdivisions = options.subdivisions;
      this.pattern = options.pattern;
      this.queue = options.queue;
      this.interval = Object.hasOwn(options, "interval") ? options.interval : 30;
      this.lookahead = Object.hasOwn(options, "lookahead") ? options.lookahead : 0.1;
      this.stepInterval = 60 / this.tempo / this.subdivisions;
      this.nextStepTime = null;
      this.step = null;
      this.intervalId = null;
      this.currentBar = null;
    }

    start() {
      this.stop();
      this.nextStepTime = this.audioCtx.currentTime;
      this.step = 0;
      this.intervalId = setInterval(() => { this.#scheduleBeeps() }, this.interval);
      this.currentBar = 0;
    }

    stop() {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
    }

    #scheduleBeeps() {
      while (this.nextStepTime < this.audioCtx.currentTime + this.lookahead) {
        this.#scheduleBeep();
        this.nextStepTime += this.stepInterval;
        this.step = (this.step + 1) % this.pattern.length;
        if (this.step == 0) {
          ++this.currentBar;
        }
      }
    }

    #scheduleBeep() {
      if (this.step % this.subdivisions == 0) {
        const beat = Math.trunc(this.step / this.subdivisions);
        this.queue.enqueue({
          beat: beat,
          beats: this.beats,
          time: this.nextStepTime,
          currentBar: this.currentBar
        });
      }

      const frequency = this.#stepFrequency();
      if (frequency) {
        const startTime = this.nextStepTime;
        const endTime = startTime + BEEP_DURATION;

        const oscillator = this.audioCtx.createOscillator();
        oscillator.type = "sawtooth";
        oscillator.frequency.value = frequency;
        oscillator.start(startTime);
        oscillator.stop(endTime);

        const gain = this.audioCtx.createGain();
        gain.gain.setValueAtTime(1, startTime);
        gain.gain.exponentialRampToValueAtTime(0.1, endTime);

        oscillator.connect(gain);
        gain.connect(this.audioCtx.destination);
      }
    }

    #stepFrequency() {
      switch (this.pattern[this.step]) {
        case HIGH: return HIGH_FREQUENCY;
        case MEDIUM: return MEDIUM_FREQUENCY;
        case LOW: return LOW_FREQUENCY;
        case HIGH: return null;
      }
    }
  }

  class Visualizer {
    constructor(options) {
      this.id = options.id;
      this.audioCtx = options.audioCtx;
      this.queue = options.queue;
      this.progressExerciseDiv = options.progressExerciseDiv;
      this.progressRepetitionDiv = options.progressRepetitionDiv;
      this.progressBarDiv = options.progressBarDiv;
      this.dotsDiv = options.dotsDiv;
      this.exercises = options.exercises;
      this.repetitions = options.repetitions;
      this.bars = options.bars;
      this.prerollBars = options.prerollBars;
      this.onFinished = options.onFinished;
      this.requestIds = [];
      this.beats = null;

      this.progressExerciseDiv.innerHTML = IDLE_HTML;
      this.progressRepetitionDiv.innerHTML = IDLE_HTML;
      this.progressBarDiv.innerHTML = IDLE_HTML;
      this.dotsDiv.replaceChildren();
    }

    start() {
      this.requestIds.push(window.requestAnimationFrame(() => this.#refresh()));
    }

    stop() {
      while (this.requestIds.length > 0) {
        const requestId = this.requestIds.pop();
        window.cancelAnimationFrame(requestId);
      }
    }

    #refresh() {
      const note = this.#nextNote();
      if (note) {
        if (!this.#update(note)) { return; }
      }
      this.requestIds.push(window.requestAnimationFrame(() => this.#refresh()));
    }

    #nextNote() {
      const time = this.audioCtx.currentTime;
      const note = this.queue.peek();
      if (!note || note.time > time) { return null; }
      return this.queue.dequeue();
    }

    #update(note) {
      if (note.beats != this.beats) {
        this.beats = note.beats;
        this.dotsDiv.replaceChildren();
        for (let i = 0; i < this.beats; ++i) {
          const e = document.createElement("div");
          e.innerHTML = (i + 1).toString();
          e.classList.add("dot");
          this.dotsDiv.appendChild(e);
        }
      }

      [...this.dotsDiv.children].forEach((e, i) => {
        if (i == note.beat) {
          e.classList.add("current");
        } else {
          e.classList.remove("current");
        }
      });

      let isLastBarOfRepetition;
      if (note.currentBar < this.prerollBars) {
        isLastBarOfRepetition = note.currentBar == this.prerollBars - 1;
        this.progressExerciseDiv.innerHTML = "preroll";
        this.progressRepetitionDiv.innerHTML = IDLE_HTML;
        this.progressBarDiv.innerHTML = formatProgress("bar", note.currentBar, this.prerollBars);
      } else {
        const overallBar = note.currentBar - this.prerollBars;
        const barsInExercise = this.bars * this.repetitions;
        const exercise = Math.trunc(overallBar / barsInExercise);
        const rem = overallBar % barsInExercise;
        const repetition = Math.trunc(rem / this.bars);
        const bar = rem % this.bars;
        isLastBarOfRepetition = repetition == this.repetitions - 1 && bar == this.bars - 1;
        const isFinished = exercise >= this.exercises;
        if (isFinished) {
          this.requestId = null;
          this.onFinished();
          return false;
        }
        this.progressExerciseDiv.innerHTML = formatProgress("exercise", exercise, this.exercises);
        this.progressRepetitionDiv.innerHTML = formatProgress("rep", repetition, this.repetitions);
        this.progressBarDiv.innerHTML = formatProgress("bar", bar, this.bars);
      }

      if (isLastBarOfRepetition) {
        this.progressExerciseDiv.classList.add("last");
        this.progressRepetitionDiv.classList.add("last");
        this.progressBarDiv.classList.add("last");
        this.dotsDiv.classList.add("last");
      } else {
        this.progressExerciseDiv.classList.remove("last");
        this.progressRepetitionDiv.classList.remove("last");
        this.progressBarDiv.classList.remove("last");
        this.dotsDiv.classList.remove("last");
      }

      return true;
    }
  }

  (() => {
    const progressExerciseDiv = document.getElementById("progress-exercise");
    const progressRepetitionDiv = document.getElementById("progress-repetition");
    const progressBarDiv = document.getElementById("progress-bar");
    const dotsDiv = document.getElementById("dots");
    const startStopBtn = document.getElementById("start-stop");
    const fields = document.getElementById("fields");
    const tempoInput = document.getElementById("tempo");
    const exercisesInput = document.getElementById("exercises");
    const repetitionsInput = document.getElementById("repetitions");
    const barsInput = document.getElementById("bars");
    const beatsInput = document.getElementById("beats");
    const subdivisionsSelect = document.getElementById("subdivisions");
    const patternInput = document.getElementById("pattern");
    const prerollBarsInput = document.getElementById("preroll-bars");

    tempoInput.value = DEFAULT_TEMPO;
    exercisesInput.value = DEFAULT_EXERCISES;
    repetitionsInput.value = DEFAULT_REPETITIONS;
    barsInput.value = DEFAULT_BARS;
    beatsInput.value = DEFAULT_BEATS;
    subdivisionsSelect.value = DEFAULT_SUBDIVISIONS;
    patternInput.value = makeDefaultPattern(DEFAULT_BEATS, DEFAULT_SUBDIVISIONS);
    prerollBarsInput.value = DEFAULT_PREROLL_BARS;

    for (const input of [tempoInput, exercisesInput, repetitionsInput, barsInput, beatsInput, prerollBarsInput]) {
      input.addEventListener("keydown", e => {
        if (e.key == "e") {
          e.preventDefault();
        }
      })
    }

    beatsInput.addEventListener("input", e => {
      if (!e.target.validity.valid) { return; }
      const beats = e.target.valueAsNumber;
      if (Number.isNaN(beats)) { return; }

      if (!subdivisionsSelect.validity.valid) { return; }
      const subdivisions = parseInt(subdivisionsSelect.value);
      if (Number.isNaN(subdivisions)) { return; }

      patternInput.value = makeDefaultPattern(beats, subdivisions);
    });

    subdivisionsSelect.addEventListener("input", e => {
      if (!e.target.validity.valid) { return; }
      const subdivisions = parseInt(e.target.value);
      if (Number.isNaN(subdivisions)) { return; }

      if (!beatsInput.validity.valid) { return; }
      const beats = beatsInput.valueAsNumber;
      if (Number.isNaN(beats)) { return; }

      patternInput.value = makeDefaultPattern(beats, subdivisions);
    });

    let visualizerId = 0;

    const audioCtx = new AudioContext();
    const queue = new Queue();
    let beeper = null;
    let visualizer = null;

    function setIdle() {
      if (beeper) {
        beeper.stop();
        beeper = null;
      }

      if (visualizer) {
        visualizer.stop();
        visualizer = null;
      }

      queue.clear();

      progressExerciseDiv.classList.remove("last");
      progressRepetitionDiv.classList.remove("last");
      progressBarDiv.classList.remove("last");
      dotsDiv.classList.remove("last");
      progressExerciseDiv.innerHTML = IDLE_HTML;
      progressRepetitionDiv.innerHTML = IDLE_HTML;
      progressBarDiv.innerHTML = IDLE_HTML;
      dotsDiv.replaceChildren();

      startStopBtn.textContent = "Start";
      fields.disabled = false;
    }

    startStopBtn.addEventListener("click", e => {
      if (e.target.textContent == "Start") {
        console.assert(!visualizer && !beeper);
        e.target.textContent = "Stop";
        fields.disabled = true;

        const tempo = tempoInput.valueAsNumber;
        const exercises = exercisesInput.valueAsNumber;
        const repetitions = repetitionsInput.valueAsNumber;
        const bars = barsInput.valueAsNumber;
        const beats = beatsInput.valueAsNumber;
        const subdivisions = parseInt(subdivisionsSelect.value);
        const pattern = parsePattern(patternInput.value, beats, subdivisions);
        const prerollBars = prerollBarsInput.valueAsNumber;

        beeper = new Beeper({
          audioCtx: audioCtx,
          tempo: tempo,
          beats: beats,
          subdivisions: subdivisions,
          pattern: pattern,
          queue: queue
        });

        visualizer = new Visualizer({
          id: ++visualizerId,
          audioCtx: audioCtx,
          queue: queue,
          progressExerciseDiv: progressExerciseDiv,
          progressRepetitionDiv: progressRepetitionDiv,
          progressBarDiv: progressBarDiv,
          dotsDiv: dotsDiv,
          exercises: exercises,
          repetitions: repetitions,
          bars: bars,
          prerollBars: prerollBars,
          onFinished: setIdle
        });

        visualizer.start();
        beeper.start();
      }
      else if (e.target.textContent == "Stop") {
        console.assert(visualizer && beeper);
        setIdle();
      }
    });

    document.addEventListener("keydown", e => {
      if (e.key == " ") {
        if (startStopBtn != document.activeElement) {
          startStopBtn.click();
        }
      }
    });
  })();
  //]]>
</script>

</html>